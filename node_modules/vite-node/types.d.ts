interface DepsHandlingOptions {
    external?: (string | RegExp)[];
    inline?: (string | RegExp)[];
    /**
     * Try to guess the CJS version of a package when it's invalid ESM
     * @default true
     */
    fallbackCJS?: boolean;
}
interface StartOfSourceMap {
    file?: string;
    sourceRoot?: string;
}
interface RawSourceMap extends StartOfSourceMap {
    version: string;
    sources: string[];
    names: string[];
    sourcesContent?: string[];
    mappings: string;
}
interface FetchResult {
    code?: string;
    externalize?: string;
    map?: RawSourceMap;
}
declare type FetchFunction = (id: string) => Promise<FetchResult>;
declare type ResolveIdFunction = (id: string, importer?: string) => Promise<ViteNodeResolveId | null>;
interface ModuleCache {
    promise?: Promise<any>;
    exports?: any;
    code?: string;
}
interface ViteNodeRunnerOptions {
    fetchModule: FetchFunction;
    resolveId: ResolveIdFunction;
    root: string;
    base?: string;
    moduleCache?: Map<string, ModuleCache>;
    interopDefault?: boolean;
    requestStubs?: Record<string, any>;
}
interface ViteNodeResolveId {
    external?: boolean | 'absolute' | 'relative';
    id: string;
    meta?: Record<string, any> | null;
    moduleSideEffects?: boolean | 'no-treeshake' | null;
    syntheticNamedExports?: boolean | string | null;
}
interface ViteNodeServerOptions {
    /**
     * Inject inline sourcemap to modules
     * @default 'inline'
     */
    sourcemap?: 'inline' | boolean;
    /**
     * Deps handling
     */
    deps?: DepsHandlingOptions;
    /**
     * Transform method for modules
     */
    transformMode?: {
        ssr?: RegExp[];
        web?: RegExp[];
    };
}

export { DepsHandlingOptions, FetchFunction, FetchResult, ModuleCache, RawSourceMap, ResolveIdFunction, StartOfSourceMap, ViteNodeResolveId, ViteNodeRunnerOptions, ViteNodeServerOptions };
